{"version":3,"sources":["fittext.js","_FWT.js","_TriMask.js","_FlightsMap.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["/*!\t\n* FitText.js 1.0 jQuery free version\n*\n* Copyright 2011, Dave Rupert http://daverupert.com \n* Released under the WTFPL license \n* http://sam.zoy.org/wtfpl/\n* Modified by Slawomir Kolodziej http://slawekk.info\n*\n* Date: Tue Aug 09 2011 10:45:54 GMT+0200 (CEST)\n*/\n(function(){\n  var css = function (el, prop) {\n    return window.getComputedStyle ? getComputedStyle(el).getPropertyValue(prop) : el.currentStyle[prop];\n  };\n  \n  var addEvent = function (el, type, fn) {\n    if (el.addEventListener)\n      el.addEventListener(type, fn, false);\n\t\telse\n\t\t\tel.attachEvent('on'+type, fn);\n  };\n  \n  var extend = function(obj,ext){\n    for(var key in ext)\n      if(ext.hasOwnProperty(key))\n        obj[key] = ext[key];\n    return obj;\n  };\n\n  window.fitText = function (el, kompressor, options) {\n\n    var settings = extend({\n      'minFontSize' : -1/0,\n      'maxFontSize' : 1/0\n    },options);\n\n    var fit = function (el) {\n      var compressor = kompressor || 1;\n\n      var resizer = function () {\n        el.style.fontSize = Math.max(Math.min(el.clientWidth / (compressor*10), parseFloat(settings.maxFontSize)), parseFloat(settings.minFontSize)) + 'px';\n      };\n\n      // Call once to set.\n      resizer();\n\n      // Bind events\n      // If you have any js library which support Events, replace this part\n      // and remove addEvent function (or use original jQuery version)\n      addEvent(window, 'resize', resizer);\n    };\n\n    if (el.length)\n      for(var i=0; i<el.length; i++)\n        fit(el[i]);\n    else\n      fit(el);\n\n    // return set of elements\n    return el;\n  };\n})();","var FWT = function() {\n\n\tthis.triMask = new this.TriMask();\n\tthis.flightsMap = new this.FlightsMap();\n\n\t//window.fitText( document.querySelectorAll('[data-fittext]'), 1.7 );\t\n}","FWT.prototype.TriMask = function() {\n   \n    // Constants\n    var ONE_THIRD = 1/3;\n    var TWO_THIRD = 2/3;\n    var TWO_PI = 2*Math.PI;\n    var triAngles = [\n        0,\n        ONE_THIRD*TWO_PI,\n        TWO_THIRD*TWO_PI\n    ]\n\n    // Settings\n    var colors = [[241,118,76], [232,88,59]];\n    var triWidth = 100;\n    var triHeight = triWidth * (Math.sqrt(3)/2);\n    //var imageSrcLarge = \"/images/header_wide.svg\";\n\n    var friction = 0.9;\n    var maxV = 100;\n\n    var pixelRatio = window.devicePixelRatio || 1;\n\n    // May need to do this for performance reasons\n    //var pixelRatio = Math.min(window.devicePixelRatio || 1, 1.5);\n\n    // Mouse vars\n    var moveX = 0;\n    var moveY = 0;\n    var lastX = 0;\n    var lastY = 0;\n    var mouseLastMoved;\n\n    var vx = 0;\n    var vy = 0;\n\n    // Store mutliple instances of the effect\n    var effects = [];\n    var containerEls = document.querySelectorAll('[data-triEffect]');\n\n    // Create a pattern tile to be used in all instances\n    var Pattern = function() {\n\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = triWidth*2;\n        this.canvas.height = triHeight*2;\n\n        var context = this.canvas.getContext('2d');\n        var triCount = Math.floor(window.innerWidth/triWidth)*2;\n        var gridSize = triCount * triWidth;\n        var globalAngle = 0;\n\n        this.draw = function() {\n\n            // Background color in case holes peep through\n            context.globalCompositeOperation = 'normal';\n            var color = colors[0];\n            context.fillStyle = 'rgb('+color[0]+','+color[1]+','+color[2]+')';\n            context.rect(-gridSize/2,-gridSize/2,gridSize,gridSize);\n            context.fill();\n\n            context.save();\n\n            var color = colors[1];\n            context.fillStyle = 'rgba('+color[0]+','+color[1]+','+color[2]+','+1+')';\n            \n            // Iterate triangle Rows\n            for (var j = 0; j < triCount; j++) {\n\n                // Alternate offset of each row\n                var bool = j % 2;\n                var xOffset = triWidth - (2*triWidth*bool);\n                context.translate(xOffset,triHeight);\n                \n                // Adjust x position with mouse X, alternate +/- on row\n                var posX = (moveX - (2*moveX*bool))/10;\n                \n                // Alternate the blend mode for each row;\n                if (bool) {\n                    context.globalCompositeOperation = 'difference';\n                } else {\n                    context.globalCompositeOperation = 'screen';\n                }\n\n                for (var i = 0; i < triCount; i++ ) {\n\n                    // Adjust y position with mouse y, alternate +/- on rcolow\n                    var bool = i % 2;\n                    var posY = (moveY - (2*moveY*bool))/10  - (gridSize/2);\n\n                    // Draw triangle, alternate up/down rotation while adding the global rotation\n                    this.triangle(triWidth, colors[bool], (Math.PI*bool)+globalAngle, (i*triWidth)+posX - (gridSize/2), posY);\n\n                }\n            }   \n\n            globalAngle+=0.003;\n            \n            context.restore();\n\n           \n        };\n\n         // Generates triangle at any position/rotation/color\n        this.triangle = function(r, color, angle, x, y) {\n\n            var angleX, angleY;\n\n            // Rotation\n            angle = angle + ONE_THIRD*Math.PI/2;\n\n            context.beginPath();\n            context.fillStyle = 'rgba('+color[0]+','+color[1]+','+color[2]+','+1+')';\n            \n            // Triangle points calculated using third angles on a circle\n            for (var i=0; i < triAngles.length; i++) {\n\n                angleX = r*Math.cos(triAngles[i] + angle) + x;\n                angleY = r*Math.sin(triAngles[i] + angle) + y;\n\n                if (i == 0) {\n                   context.moveTo(angleX,angleY); \n                } else {\n                    context.lineTo(angleX,angleY); \n                } \n\n            }\n\n            context.fill();\n            context.closePath();\n\n        }\n\n\n    }\n\n    // Use pattern tile on a canvas\n    var Effect = function(elContainer) {\n\n        var self = this;\n\n        var elCanvas = elContainer.querySelector('canvas');\n        var context = elCanvas.getContext('2d');\n\n        var maskImageUrl = elContainer.dataset.trieffect;\n\n        var context = elCanvas.getContext('2d');\n        var maskImage, imageRatio;\n\n        var width, height, cx, cy;\n\n        this.draw = function() {\n\n            // Don't draw unless image loaded\n            if (!imageRatio && maskImageUrl) { return };\n\n            context.save();\n\n            var pattern = context.createPattern(globalPattern.canvas, \"repeat\");\n            context.fillStyle = pattern;\n            context.fillRect(0,0,width,height);\n\n             // Apply masked text image\n            if (maskImageUrl) {\n                context.globalCompositeOperation = 'destination-in';\n                context.setTransform(1,0,0,1,0,0);\n                context.drawImage(maskImage,0,0, width, width*imageRatio);\n            }\n\n            context.restore();\n        }\n\n        this.resize = function() {\n\n            // Canvas sizing stuff\n            width = Math.floor(elCanvas.width = elContainer.clientWidth * pixelRatio);\n\n            if (imageRatio) {\n                height = Math.floor(elCanvas.height = (width/pixelRatio)*imageRatio * pixelRatio);\n            } else {\n                height = Math.floor(elCanvas.height = elContainer.clientHeight * pixelRatio);\n            }\n\n            cx = width/2;\n            cy = height/2;\n\n            context.scale(pixelRatio,pixelRatio);\n\n            elCanvas.style.width = Math.floor(width/pixelRatio)+\"px\";\n            elCanvas.style.height = Math.floor(height/pixelRatio)+\"px\";\n\n        }\n\n        window.addEventListener('resize', this.resize);\n\n        if (maskImageUrl) {\n            maskImage = new Image();\n            maskImage.src = maskImageUrl;\n\n            maskImage.onload = function() {\n            \n                imageRatio = this.height/this.width;\n\n                self.resize();\n            }\n            \n        } else {\n            this.resize();\n        }        \n\n    }\n\n    // var resize = function() {\n\n    //     checkScreenWidth();\n\n    // }\n\n    // var checkScreenWidth = function() {\n\n    //     if (Modernizr.mq('(max-width: 600px)') && usingImage != 'small') {\n\n    //         headerImage.src = imageSrcSmall\n    //         usingImage = 'small';\n\n    //     } else if (Modernizr.mq('(min-width: 600px)') && usingImage != 'large') {\n    //         headerImage.src = imageSrcLarge;\n    //         usingImage = 'large';\n    //     }    \n       \n    // }\n\n\n    var handleMouseMove = function(e) {\n\n        if (!mouseLastMoved) {\n            mouseLastMoved = Date.now();\n        }\n\n        // if (!mouseMoving) {\n        //     moveXStart = e.clientX;\n        //     moveYStart = e.clientY;\n        //     mouseMoving = true;\n        // }\n\n        // If last mouse recorded 10th of a second ago\n        if (mouseLastMoved < Date.now() - 50) {\n            // Get speed of mouse\n            vx = e.clientX - lastX;\n            vy = e.clientY - lastY;\n\n            // Update new values of mouse to check next time\n            lastX = e.clientX;\n            lastY = e.clientY;\n            mouseLastMoved = Date.now();\n\n        }\n    }\n\n\n    var handlePhysics = function() {\n\n        if (vx > maxV) {\n            vx = maxV;\n        } else if (vx < -maxV) {\n            vx = -maxV;\n        }\n\n        if (vy > maxV) {\n            vy = maxV;\n        } else if (vy < -maxV) {\n            vy = -maxV;\n        }\n     \n\n        vx = vx*friction;\n        vy = vy*friction;\n\n        moveX += vx;\n        moveY += vy;\n    }\n\n    var drawAll = function() {\n\n        globalPattern.draw();\n\n        for (var i=0; i<effects.length; i++) {\n            effects[i].draw();\n        }\n\n    }\n\n\n    window.addEventListener('mousemove', handleMouseMove);\n    window.addEventListener('devicemotion', function(e) {\n\n        ax = e.acceleration.x;\n        ay = e.acceleration.y;\n        az = e.acceleration.z;\n\n        if (ax > 0.5 || ax < -0.5) {\n            vx = ax * 10;\n        }\n\n        if (ay > 0.5 || ay < -0.5) {\n            vy = ay * 10;\n        }\n\n        if (az > 0.5 || az < -0.5) {\n            vy = az * 10;\n        }\n      \n    });\n\n    var globalPattern = new Pattern();\n\n    // Create instances of effect\n    for (var i=0; i<containerEls.length; i++) {\n\n        effects.push(new Effect(containerEls[i]));\n\n    }\n\n    requestAnimationFrame(function animLoop(){\n        handlePhysics(); \n        drawAll();\n        requestAnimationFrame( animLoop );\n    });\n}\n\n","FWT.prototype.FlightsMap = function() {\n\n\tvar pathEls = document.querySelectorAll('svg #flights path');\n\tvar paths = [];\n\tvar transEndEventName = ('WebkitTransition' in document.documentElement.style) ? 'webkitTransitionEnd' : 'transitionend';\n\n\t// If no flights map, get out of there! ;)\n\tif (!pathEls.length) {\n\t\treturn\n\t}\n\n\t// Each path on the map\n\tvar Path = function(path, index) {\n\n\t\tvar self = this;\n\n\t\tthis.init = function() {\n\n\t\t\tthis.length = path.getTotalLength();\n\t\t\tthis.index = index;\n\t\t\tthis.reset();\n\n\t\t}\n\n\t\tthis.go = function() {\n\t\t\tthis.reset();\n\t\t\tpath.style.strokeDashoffset = self.length;\n\t\t}\n\n\t\tthis.reset = function() {\n\n\t\t\t// Clear any previous transition\n\t\t\tpath.style.transition = path.style.WebkitTransition = 'none';\n\t\t\t\n\t\t\t// Set up the starting positions\n\t\t\tpath.style.strokeDasharray = this.length + ' ' + this.length;\n\t\t\tpath.style.strokeDashoffset = -this.length;\n\t\t\t\n\t\t\t// Trigger a layout so styles are calculated & the browser\n\t\t\t// picks up the starting position before animating\n\t\t\tpath.getBoundingClientRect();\n\t\t\t// Define our transition\n\t\t\tpath.style.transition = path.style.WebkitTransition = 'stroke-dashoffset 1s ease-in-out';\n\n\t\t}\n\t \n\t}\n\n\t// Create new objects for each path tag in the svg\n\tfor (var i=0; i<pathEls.length; i++) {\n\n\t\tvar path = new Path(pathEls[i]);\n\t\tpath.init();\n\n\t\tpaths.push(path);\n\n\t}\n\n\t// 3 counting vars, offset by 3\n\t// Allowing for 3 paths to be animated at a time\n\tvar i = paths.length-1;\n\tvar j = paths.length-3;\n\tvar k = paths.length-5;\n\n\t// Set off animations every second\n\tvar t = window.setInterval(function() {\n\t\t\n\t\tpaths[i].go();\n\t\tpaths[j].go();\n\t\tpaths[k].go();\n\n\t\ti--; j--; k--;\n\n\t\tif (i < 0) {\n\t\t\ti = paths.length-1;\n\t\t}\n\n\t\tif (j < 0) {\n\t\t\tj = paths.length-1;\n\t\t}\n\n\t\tif (k < 0) {\n\t\t\tk = paths.length-1;\n\t\t}\n\n\t}, 1000)\n}"],"sourceRoot":"/source/"}